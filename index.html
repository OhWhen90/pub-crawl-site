<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes" />
  <title>Pub Crawl Challenge List</title>
  <style>
    body {
      font-family: sans-serif;
      font-size: 18px;
      max-width: 600px;
      margin: 0 auto;
      padding: 1rem;
      background: #f9f9f9;
      color: #222;
    }
    h1, h2 {
      text-align: center;
    }
    /* Style for the riddle container */
    #riddle-container {
      text-align: center;
      margin: 1.5rem 0 2rem;
      padding: 1rem;
      background-color: #e8f5e9;
      border: 1px solid #c8e6c9;
      border-radius: 8px;
      font-style: italic;
      color: #388e3c;
      font-size: 1.1em;
      line-height: 1.5;
    }
    #riddle-answer {
      font-weight: bold;
      margin-top: 1em;
      color: #1b5e20;
    }

    label {
      display: flex;
      align-items: flex-start;
      padding: 0.6rem 0;
      font-size: 1.2rem;
      cursor: pointer;
    }
    input[type="checkbox"] {
      margin-right: 1rem;
      transform: scale(1.3);
    }
    .emoji {
      margin-right: 0.3rem;
      font-size: 1.4rem;
    }
    /* Make the clickable emoji hint at interaction */
    .secret-trigger-emoji {
      cursor: pointer;
      /* Optional: Add a subtle visual hint, e.g., a slight shadow or underline on hover */
      /* text-shadow: 0 0 2px rgba(0,0,0,0.2); */
      /* transition: text-shadow 0.2s ease; */
    }
    /* .secret-trigger-emoji:hover {
        text-shadow: 0 0 5px rgba(0,0,0,0.4);
    } */

    .challenge-title {
      font-weight: bold;
    }
    .challenge-desc {
      margin-left: 2.7rem;
      font-size: 1rem;
      color: #555;
      margin-top: -0.3rem;
    }
    .bonus, .rainbow {
      margin-left: 2.7rem;
      font-size: 0.95rem;
      color: #444;
    }
    .rainbow input[type="checkbox"],
    .bonus input[type="checkbox"] {
      transform: scale(1.1);
      margin-right: 0.4rem;
    }
    .rainbow label {
      display: block;
      width: 100%;
      margin-top: 0.3rem;
    }
    #reset-btn {
      margin: 2rem auto 1rem;
      display: block;
      font-size: 1.3rem;
      background: #e74c3c;
      color: white;
      border: none;
      padding: 0.7rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
      transition: background 0.3s ease;
    }
    #reset-btn:hover {
      background: #c0392b;
    }

    /* Style for the secret challenges container */
    #secret-challenge-section {
      opacity: 0;
      max-height: 0;
      overflow: hidden;
      transition: opacity 0.7s ease-in-out, max-height 0.7s ease-in-out;
      pointer-events: none;
      margin-top: 2rem;
      border-top: 2px dashed #ccc;
      padding-top: 1rem;
    }
    #secret-challenge-section.revealed {
      opacity: 1;
      max-height: 3000px; /* Keeping the generous height */
      pointer-events: auto;
    }
    #secret-challenge-section h2 {
        color: #5a2a8b;
    }
    /* Style for new subheadings within the secret section */
    .secret-subheader {
        text-align: center;
        color: #4a1c7c;
        margin-top: 1.5rem;
        margin-bottom: 1rem;
        font-size: 1.3rem;
        font-weight: bold;
    }

    /* Style for the secret challenge tracker, now part of main score display */
    #secret-challenges-count {
      text-align: center;
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      color: #5a2a8b;
      opacity: 0;
      display: none;
      transition: opacity 0.7s ease-in-out;
    }
    /* Make it visible when the secret section is revealed */
    #secret-challenge-section.revealed ~ div #secret-challenges-count {
        opacity: 1;
        display: block;
    }
    /* Added style for the new line in secret challenge descriptions */
    .secret-desc-new-line {
        display: block;
        margin-left: 2.7rem;
        margin-top: 0.3em;
        font-style: italic;
        color: #666;
    }
  </style>
</head>
<body>

<h1 id="main-heading">Pub Crawl Challenge List</h1>

<div id="riddle-container">
  A grand adventure, now begins,<br>
  Through taverns vast, where joy within.<br>
  Ten trials await, for laughs and cheer,<br>
  Your progress charted, banishing fear.<br><br>

  But should you seek what lies beyond,<br>
  A deeper quest, a magic wand...<br>
  Trace steps unseen, then hush your plea,<br>
  And capture moments, for all to see.<br><br>

  What am I, on this journey grand,<br>
  That guides your steps, with secrets at hand?
  <div id="riddle-answer">... Your Challenge List!</div>
</div>

<div id="challenge-container"></div>

<div id="secret-challenge-section">
    <h2 style="text-align: center;">ğŸ¤« Secret Challenges! ğŸ¤«</h2>
    <div id="secret-challenge-container"></div>
</div>

<div style="text-align: center; margin-top: 2rem; font-size: 1.2rem;">
  <div id="main-count">âœ”ï¸ Challenges Completed: 0 / 10</div>
  <div id="bonus-count">â­ Bonus Points Earned: 0 / 0</div>
  <div id="secret-challenges-count">ğŸ Secret Challenges Completed: 0 / 3</div>
  <div id="total-score">ğŸ† Total Score: 0 / 10</div>
</div>

<button id="reset-btn">Reset Progress</button>

<script>
  const STORAGE_KEY = "pubCrawlChallengeProgress";
  // Removed SECRET_SECTION_KEY as it's no longer used for persistence

  const challenges = [
    { id: 0, emojis: ["ğŸ”", "ğŸ‘•"], title: "Closet Shuffle.", desc: "Swap an item of clothing with someone for the entire time at one location." },
    { id: 1, emojis: ["ğŸŒˆ", "ğŸ¹"], title: "Taste the Rainbow.", desc: "Drink two different colours of the rainbow â€” use cocktails, shots, or even mixers.", rainbow: true },
    { id: 2, emojis: ["ğŸ¥¤", "ğŸ¸"], title: "The Diana Special.", desc: "Finish your entire drink using three (or more) straws at once." },
    { id: 3, emojis: ["ğŸ”™", "<span class='secret-trigger-emoji' data-emoji-code='foot'>ğŸš¶â€â™‚ï¸</span>"], title: "Backwards Journey.", desc: "Walk backwards between any two crawl stops. Safety first, though â€” have a guide!" },
    { id: 4, emojis: ["ğŸ§¦", "âœ‹"], title: "Sock Puppet Hour.", desc: "Wear a sock on your right hand for the entire time at one location. Introduce it as your new drinking buddy." },
    { id: 5, emojis: ["ğŸ•º", "ğŸ’ƒ"], title: "Dance-Off Destiny.", desc: "Join or start a dance-off.", bonus: "If you win or get strangers to cheer." },
    { id: 6, emojis: ["<span class='secret-trigger-emoji' data-emoji-code='shush'>ğŸ¤«</span>", "ğŸ“"], title: "The Sneaky Peg.", desc: "Clip your peg on someone without them noticing â€” it must stay there for 15 minutes. Proof required!", bonus: "Someone leaves a crawl stop wearing your peg.", bonusAlwaysEnabled: true },
    { id: 7, emojis: ["ğŸ­", "ğŸ—£ï¸"], title: "Accent Order (Encore).", desc: "Order your drink in a full accent (e.g. French, pirate, cowboy, Scottish).", bonus: "Stay in character until you have finished your drink." },
    { id: 8, emojis: ["ğŸ“¸", "<span class='secret-trigger-emoji' data-emoji-code='selfie'>ğŸ¤³</span>"], title: "The Hospitality Selfie.", desc: "Take a selfie with either a bartender or a bouncer.", bonus: "If they smile." },
    { id: 9, emojis: ["ğŸ»", "ğŸ¥‚"], title: "The Icebreaker Toast.", desc: "Walk up to a complete stranger (or another group) and confidently give a short but passionate toast in their honour.", bonus: "They toast back." }
  ];

  const secretChallenges = [
    { type: "subheader", text: "ğŸ’§ Owen's Hydration Fund ğŸ’§" },
    { id: 10, emojis: ["ğŸ’°", "ğŸ¹"], title: "The Generosity Gambit: Round One.", desc: "Buy Owen a drink.", quote: "It's for science, and good karma (mostly science)."},
    { id: 11, emojis: ["ğŸ’¸", "ğŸ¸"], title: "The Double Down Delight: Round Two.", desc: "Buy Owen *another* drink.", quote: "Clearly, his thirst is legendary. Or he's just really good at this game."},
    { id: 12, emojis: ["ğŸ¤‘", "ğŸ¥‚"], title: "The Triple Treat Triumph: Round Three.", desc: "Buy Owen a *third* drink.", quote: "At this point, it's less a challenge, more an investment in his happiness. And your score."},
    
    { type: "subheader", text: "ğŸ“¢ Public Embarrassment Tour ğŸ“¢" },
    { id: 13, emojis: ["ğŸ¨", "ğŸ—£ï¸"], title: "Occidental Grand Entrance.", desc: "Upon entering the Occidental Hotel, enthusiastically declare:", quote: "â€œLet the crawl begin! May our memories be blurry and our drinks be strong!â€"},
    { id: 14, emojis: ["ğŸ¥·", "ğŸ—£ï¸"], title: "Uncle Ming's Mystic Welcome.", desc: "As you enter Uncle Mingâ€™s, state with gravitas:", quote: "â€œWe come seeking wisdomâ€¦ and whiskey!â€ (Optional: perform a ninja bow or hands in prayer)."},
    { id: 15, emojis: ["ğŸš‹", "ğŸ—£ï¸"], title: "Light Rail Loudspeaker.", desc: "Boarding the Light Rail from Wynyard, announce:", quote: "â€œTo the next round, we ride! Conduct us to chaos!â€"},
    { id: 16, emojis: ["âš“", "ğŸ—£ï¸"], title: "The Ship Inn's Salty Salute.", desc: "Entering The Ship Inn, exclaim:", quote: "â€œAhoy, Ship Inn! Weâ€™re here to sail the seas of spirits!â€"},
    { id: 17, emojis: ["ğŸ½", "ğŸ—£ï¸"], title: "Jackson's Dinner Declaration.", desc: "At Jacksonâ€™s on George, proclaim:", quote: "â€œRefuel the adventurers! Ale in hand, fork at the ready!â€"},
    { id: 18, emojis: ["ğŸ°", "ğŸ—£ï¸"], title: "Fortune's Fierce Proclamation.", desc: "Upon entering the Fortune of War, yell:", quote: "â€œTo battle! We drink in the name of victory!â€ (Optional: mime a sword-in-the-air)."},
    { id: 19, emojis: ["ğŸº", "ğŸ—£ï¸"], title: "Munich Brauhaus Boisterous Bonjour.", desc: "Inside Munich Brauhaus, bellow:", quote: "â€œProst! Bring forth the beer and the bratwurst!â€ (Ensure to yell 'Prost!' and clink imaginary glasses)."},
    { id: 20, emojis: ["ğŸ’ƒ", "ğŸ—£ï¸"], title: "Dance Floor Dynamo.", desc: "As you enter Cruise Bar and/or Orient Hotel, declare:", quote: "â€œWe danced our way through drinks â€” now letâ€™s drink our way through dance!â€"}
  ];

  const rainbowColors = ["red", "orange", "yellow", "green", "blue", "indigo", "violet"];

  const allChallenges = [...challenges, ...secretChallenges.filter(ch => ch.type !== 'subheader')];

  // Sequence for revealing secret challenges
  const SECRET_EMOJI_SEQUENCE = ['foot', 'shush', 'selfie'];
  let currentSequenceIndex = 0;
  let lastClickTime = 0;
  const SEQUENCE_TIMEOUT_MS = 1000; // 1 second to complete the sequence after the first click

  function saveProgress() {
    const state = {};
    allChallenges.forEach(ch => {
      const mainCheckbox = document.getElementById(`chk${ch.id}`);
      if (mainCheckbox) state[`chk${ch.id}`] = mainCheckbox.checked;
      const bonusCheckbox = document.getElementById(`chk${ch.id}b`);
      if (bonusCheckbox) state[`chk${ch.id}b`] = bonusCheckbox.checked;
    });
    rainbowColors.forEach(color => {
      const cb = document.getElementById(`rainbow-${color}`);
      if (cb) state[`rainbow-${color}`] = cb.checked;
    });
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }

  // Removed saveSecretSectionRevealedStatus as we no longer persist this state

  function loadProgress() {
    const stateStr = localStorage.getItem(STORAGE_KEY);
    if (!stateStr) return;
    const state = JSON.parse(stateStr);
    Object.entries(state).forEach(([key, val]) => {
      const el = document.getElementById(key);
      if (el) el.checked = val;
    });

    // Secret section will *always* start hidden on load, so no check needed here.
    const secretSection = document.getElementById("secret-challenge-section");
    if (secretSection) {
      secretSection.classList.remove("revealed"); // Ensure it's hidden
    }
    updateScore();
  }

  function createChallengeElement(ch) {
    if (ch.type === "subheader") {
      const subheaderDiv = document.createElement("div");
      subheaderDiv.className = "secret-subheader";
      subheaderDiv.textContent = ch.text;
      return subheaderDiv;
    }

    const label = document.createElement("label");
    label.id = `challenge-item-${ch.id}`;

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.id = `chk${ch.id}`;
    if (ch.id === 1) checkbox.disabled = true;
    label.appendChild(checkbox);

    // Render emojis, adding the secret-trigger-emoji class if it's part of our sequence
    ch.emojis.forEach(e_html => {
      // Create a temporary element to parse the HTML string
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = e_html;
      const emojiElement = tempDiv.firstChild;

      if (emojiElement && emojiElement.nodeType === 1 && emojiElement.classList.contains('secret-trigger-emoji')) {
        // If it's a wrapped emoji, append the wrapper
        label.appendChild(emojiElement.cloneNode(true)); // Clone to avoid moving it from tempDiv
      } else {
        // If it's a regular emoji string, create a span for it
        const span = document.createElement("span");
        span.className = "emoji";
        span.textContent = e_html; // Use textContent for raw emoji string
        label.appendChild(span);
      }
    });

    const div = document.createElement("div");
    const titleSpan = document.createElement("span");
    titleSpan.className = "challenge-title";
    titleSpan.textContent = ch.title;
    div.appendChild(titleSpan);

    const descDiv = document.createElement("div");
    descDiv.className = "challenge-desc";
    descDiv.textContent = ch.desc;
    div.appendChild(descDiv);

    if (ch.quote) {
      const quoteDiv = document.createElement("div");
      quoteDiv.className = "secret-desc-new-line";
      quoteDiv.textContent = ch.quote;
      div.appendChild(quoteDiv);
    }

    if (ch.rainbow) {
      const colorContainer = document.createElement("div");
      colorContainer.className = "rainbow";
      const emojis = {
        red: "ğŸ”´", orange: "ğŸŸ ", yellow: "ğŸŸ¡", green: "ğŸŸ¢",
        blue: "ğŸ”µ", indigo: "ğŸŸ£", violet: "ğŸŸ£"
      };
      rainbowColors.forEach(color => {
        const capitalized = color.charAt(0).toUpperCase() + color.slice(1);
        colorContainer.innerHTML += `<label><input type="checkbox" id="rainbow-${color}">${emojis[color]} ${capitalized}</label>`;
      });
      colorContainer.innerHTML += `<div class="bonus" style="margin-top:0.3rem;">â­ Bonus: Each additional colour beyond two.</div>`;
      div.appendChild(colorContainer);
    }

    if (ch.bonus) {
      const bonusContainer = document.createElement("div");
      bonusContainer.className = "bonus";
      bonusContainer.innerHTML = `<input type="checkbox" id="chk${ch.id}b" ${ch.bonusAlwaysEnabled ? 'data-always' : 'disabled'} />â­ Bonus: ${ch.bonus}`;
      div.appendChild(bonusContainer);
    }

    label.appendChild(div);
    return label;
  }

  function createChallenges() {
    const mainContainer = document.getElementById("challenge-container");
    const secretContainer = document.getElementById("secret-challenge-container");
    mainContainer.innerHTML = "";
    secretContainer.innerHTML = "";

    challenges.forEach(ch => {
      mainContainer.appendChild(createChallengeElement(ch));
    });

    let secretChallengesRenderedCount = 0;
    secretChallenges.forEach(ch => {
      secretContainer.appendChild(createChallengeElement(ch));
      if (ch.type !== 'subheader') {
        secretChallengesRenderedCount++;
      }
    });
    console.log(`[DEBUG] Attempted to render ${secretChallengesRenderedCount} secret challenges (excluding subheaders). Expected: ${secretChallenges.filter(c => c.type !== 'subheader').length}`);
  }

  function updateScore() {
    let mainChallengesCompleted = 0;
    let bonusPointsEarned = 0;
    let rainbowColorsChecked = 0;
    let secretChallengesCompleted = 0;

    rainbowColors.forEach(color => {
      const cb = document.getElementById("rainbow-" + color);
      if (cb && cb.checked) rainbowColorsChecked++;
    });

    const rainbowMainCheckbox = document.getElementById("chk1");
    if (rainbowMainCheckbox) {
      if (rainbowColorsChecked >= 2) {
        if (!rainbowMainCheckbox.checked) rainbowMainCheckbox.checked = true;
        if (rainbowColorsChecked > 2) bonusPointsEarned += (rainbowColorsChecked - 2);
      } else {
        rainbowMainCheckbox.checked = false;
      }
    }

    const secretSection = document.getElementById("secret-challenge-section");
    const isSecretSectionRevealed = secretSection.classList.contains("revealed");
    const secretChallengesTracker = document.getElementById("secret-challenges-count");

    allChallenges.forEach(ch => {
      const mainCheckbox = document.getElementById("chk" + ch.id);
      const bonusCheckbox = document.getElementById("chk" + ch.id + "b");

      const isSecret = ch.id >= 10;

      if (mainCheckbox && mainCheckbox.checked) {
          if (isSecret && isSecretSectionRevealed) { // Only count if revealed
              secretChallengesCompleted++;
          } else if (!isSecret && ch.id !== 1) {
              mainChallengesCompleted++;
          }
      }
      if (bonusCheckbox && bonusCheckbox.checked) {
          if (isSecret && isSecretSectionRevealed) { // Only count if revealed
            bonusPointsEarned++;
          } else if (!isSecret) {
            bonusPointsEarned++;
          }
      }
    });

    if (rainbowMainCheckbox && rainbowMainCheckbox.checked) {
        mainChallengesCompleted++;
    }

    let maxMainChallengesPossible = challenges.length;
    let maxBonusPointsPossible = 0;
    challenges.forEach(ch => {
        if (ch.bonus && ch.id !== 1) {
            maxBonusPointsPossible++;
        }
    });
    maxBonusPointsPossible += Math.max(0, rainbowColors.length - 2);

    let maxTotalScorePossible = maxMainChallengesPossible + maxBonusPointsPossible;
    let actualSecretChallengesCount = secretChallenges.filter(ch => ch.type !== 'subheader').length;

    if (isSecretSectionRevealed) {
        // If revealed, add the secret challenges possible to the total
        maxTotalScorePossible += actualSecretChallengesCount;
    }

    const currentTotalScore = mainChallengesCompleted + bonusPointsEarned + secretChallengesCompleted;

    document.getElementById("main-count").textContent = `âœ”ï¸ Challenges Completed: ${mainChallengesCompleted} / ${challenges.length}`;
    document.getElementById("bonus-count").textContent = `â­ Bonus Points Earned: ${bonusPointsEarned} / ${maxBonusPointsPossible}`;
    document.getElementById("total-score").textContent = `ğŸ† Total Score: ${currentTotalScore} / ${maxTotalScorePossible}`;

    if (secretChallengesTracker) {
        if (isSecretSectionRevealed) {
            secretChallengesTracker.textContent = `ğŸ Secret Challenges Completed: ${secretChallengesCompleted} / ${actualSecretChallengesCount}`;
            secretChallengesTracker.style.display = 'block';
            setTimeout(() => secretChallengesTracker.style.opacity = '1', 10);
        } else {
            secretChallengesTracker.style.opacity = '0';
            setTimeout(() => secretChallengesTracker.style.display = 'none', 700);
        }
    }
  }

  function resetProgress() {
    localStorage.removeItem(STORAGE_KEY);
    // Removed localStorage.removeItem(SECRET_SECTION_KEY) as it's no longer used

    allChallenges.forEach(ch => {
      const chk = document.getElementById(`chk${ch.id}`);
      if (chk) chk.checked = false;
      const bchk = document.getElementById(`chk${ch.id}b`);
      if (bchk) {
        bchk.checked = false;
        if (!bchk.hasAttribute("data-always")) {
          bchk.disabled = true;
        }
      }
    });
    rainbowColors.forEach(color => {
      const cb = document.getElementById(`rainbow-${color}`);
      if (cb) cb.checked = false;
    });

    const secretSection = document.getElementById("secret-challenge-section");
    if (secretSection) {
      secretSection.classList.remove("revealed"); // Ensure it's hidden on reset
    }

    const secretChallengesTracker = document.getElementById("secret-challenges-count");
    if (secretChallengesTracker) {
        secretChallengesTracker.style.opacity = '0';
        secretChallengesTracker.style.display = 'none';
        secretChallengesTracker.textContent = `ğŸ Secret Challenges Completed: 0 / ${secretChallenges.filter(ch => ch.type !== 'subheader').length}`;
    }

    // Reset sequence tracking
    currentSequenceIndex = 0;
    lastClickTime = 0;

    updateScore();
    saveProgress();
  }

  document.addEventListener("DOMContentLoaded", () => {
    createChallenges();
    loadProgress(); // This will now ensure the secret list starts hidden

    // Event listener for the secret emoji sequence
    document.getElementById("challenge-container").addEventListener("click", (event) => {
      const target = event.target;

      // Check if the clicked element is one of our secret trigger emojis
      if (target.classList.contains('secret-trigger-emoji')) {
        const emojiCode = target.dataset.emojiCode; // Get the custom data attribute

        const currentTime = Date.now();

        // If the current click is within the timeout window OR it's the very first click in a new sequence
        if (currentTime - lastClickTime < SEQUENCE_TIMEOUT_MS || currentSequenceIndex === 0) {
          if (emojiCode === SECRET_EMOJI_SEQUENCE[currentSequenceIndex]) {
            currentSequenceIndex++;
            lastClickTime = currentTime; // Update last click time
            console.log(`[Secret Sequence] Correct click: ${emojiCode}. Index: ${currentSequenceIndex}`);

            if (currentSequenceIndex === SECRET_EMOJI_SEQUENCE.length) {
              // Sequence completed!
              const secretSection = document.getElementById("secret-challenge-section");
              const isCurrentlyRevealed = secretSection.classList.contains("revealed");

              // Toggle visibility
              if (isCurrentlyRevealed) {
                secretSection.classList.remove("revealed");
              } else {
                secretSection.classList.add("revealed");
              }
              updateScore();
              currentSequenceIndex = 0; // Reset for next time, whether it revealed or hid
              lastClickTime = 0;
              console.log("[Secret Sequence] Revealed/Hid secret section!");
            }
          } else {
            // Incorrect click in sequence, reset
            console.log(`[Secret Sequence] Incorrect click: ${emojiCode}. Resetting sequence.`);
            currentSequenceIndex = 0;
            lastClickTime = 0;
          }
        } else {
          // Timeout, reset sequence (unless this click starts a new sequence)
          console.log("[Secret Sequence] Timeout. Resetting sequence.");
          currentSequenceIndex = 0;
          lastClickTime = 0;
          // If this click is the start of the sequence
          if (emojiCode === SECRET_EMOJI_SEQUENCE[0]) {
            currentSequenceIndex = 1;
            lastClickTime = currentTime;
            console.log(`[Secret Sequence] Started new sequence with: ${emojiCode}`);
          }
        }
      }
    });

    document.addEventListener("change", e => {
      const id = e.target.id;

      if (id.startsWith("chk") && !id.endsWith("b")) {
        const bonusBox = document.getElementById(id + "b");
        if (bonusBox && !bonusBox.hasAttribute("data-always")) {
          bonusBox.disabled = !e.target.checked;
          if (!e.target.checked) bonusBox.checked = false;
        }
      }

      updateScore();
      saveProgress();
    });

    document.getElementById("reset-btn").addEventListener("click", () => {
      if (confirm("Are you sure you want to reset all progress? This will also re-hide the secret challenges.")) {
        resetProgress();
      }
    });
  });
</script>

</body>
</html>
