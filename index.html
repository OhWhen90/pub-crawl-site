<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes" />
  <title>Pub Crawl Challenge List</title>
  <style>
    body {
      font-family: sans-serif;
      font-size: 18px;
      max-width: 600px;
      margin: 0 auto;
      padding: 1rem;
      background: #f9f9f9;
      color: #222;
    }
    h1, h2 {
      text-align: center;
    }
    /* Style for the riddle container */
    #riddle-container {
      text-align: center;
      margin: 1.5rem 0 2rem;
      padding: 1rem;
      background-color: #e8f5e9;
      border: 1px solid #c8e6c9;
      border-radius: 8px;
      font-style: italic;
      color: #388e3c;
      font-size: 1.1em;
      line-height: 1.5;
      max-height: 1000px; /* Initial large height for transition */
      transition: opacity 0.6s ease-out, max-height 0.6s ease-out, padding 0.6s ease-out, margin 0.6s ease-out, border 0.6s ease-out;
    }
    /* Style when riddle is hidden */
    #riddle-container.riddle-hidden {
      opacity: 0;
      max-height: 0; /* Collapse to 0 */
      padding-top: 0;
      padding-bottom: 0;
      margin-top: 0;
      margin-bottom: 0;
      border: none; /* Remove border */
      overflow: hidden;
      pointer-events: none; /* Make content non-interactive when hidden */
    }
    #riddle-answer {
      font-weight: bold;
      margin-top: 1em;
      color: #1b5e20;
    }

    #hide-riddle-btn {
        margin-top: 1.5rem;
        padding: 0.6rem 1.2rem;
        background-color: #388e3c; /* Darker green */
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1rem;
        transition: background 0.3s ease;
    }
    #hide-riddle-btn:hover {
        background-color: #2e7d32;
    }

    #show-riddle-btn {
        display: block;
        margin: 1rem auto;
        padding: 0.5rem 1rem;
        background-color: #66bb6a; /* Greenish */
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: opacity 0.6s ease-out, max-height 0.6s ease-out;
        opacity: 0;
        max-height: 0;
        overflow: hidden; /* Important to hide it completely */
        pointer-events: none; /* Make non-interactive when hidden */
    }

    #show-riddle-btn.visible {
        opacity: 1;
        max-height: 50px; /* Sufficient height for button */
        pointer-events: auto;
    }

    .challenge-item { /* New class for the main challenge container */
      display: flex; /* Use flexbox for alignment */
      align-items: flex-start;
      padding: 0.6rem 0;
    }
    .challenge-item .checkbox-container {
        display: flex;
        align-items: flex-start;
    }
    .challenge-item .checkbox-container input[type="checkbox"] {
        margin-right: 1rem;
        transform: scale(1.3);
        cursor: pointer;
    }

    /* Styling for disabled checkboxes */
    input[type="checkbox"]:disabled {
      opacity: 0.6; /* Make it slightly transparent */
      cursor: not-allowed; /* Change cursor to indicate it's not clickable */
    }

    /* Optional: also grey out the associated label text, emojis, and title when main checkbox is disabled */
    .challenge-item .checkbox-container input[type="checkbox"]:disabled ~ .emojis-container,
    .challenge-item .checkbox-container input[type="checkbox"]:disabled ~ .challenge-details .challenge-title,
    .challenge-item .checkbox-container input[type="checkbox"]:disabled ~ .challenge-details .challenge-desc {
      color: #999; /* Lighter grey for text */
    }

    /* Keep the bonus/rainbow labels clickable if their checkbox isn't disabled */
    .rainbow label input[type="checkbox"]:not(:disabled) + span,
    .bonus label input[type="checkbox"]:not(:disabled) + span,
    .bonus-line label input[type="checkbox"]:not(:disabled) + span {
      cursor: pointer;
    }
    /* Apply grey out to bonus/rainbow labels specifically when THEIR checkbox is disabled */
    .rainbow label input[type="checkbox"]:disabled + span,
    .bonus label input[type="checkbox"]:disabled + span,
    .bonus-line label input[type="checkbox"]:disabled + span {
      color: #999;
      cursor: not-allowed;
    }


    .emojis-container { /* Container for emojis */
      display: flex;
      align-items: center;
      margin-right: 0.5rem;
    }
    .emoji {
      font-size: 1.4rem;
      line-height: 1;
      margin-right: 0.3rem;
    }

    /* New styles for the clickable wrapper around secret trigger emojis */
    .secret-trigger-wrapper {
      display: inline-block; /* Allows padding to expand clickable area */
      padding: 8px; /* Adjust as needed for desired hitbox size */
      margin: -8px; /* Negative margin to pull it back and prevent affecting surrounding layout */
    }

    .secret-trigger-emoji {
      cursor: pointer !important;
      transition: transform 0.1s ease-out;
    }
    .secret-trigger-emoji:active {
      transform: scale(0.9);
    }

    .challenge-details {
        flex-grow: 1;
    }
    .challenge-title {
      font-weight: bold;
      cursor: pointer;
    }
    /* Specific style for secret challenge titles - purple! */
    #secret-challenge-container .challenge-title {
        color: #5a2a8b; /* Purple color for secret challenge titles */
    }
    .challenge-desc {
      font-size: 1rem;
      color: #555;
      margin-top: 0.2rem;
    }
    /* Specific styling for the bonus line - for 'Sneaky Peg' only */
    .bonus-line {
      font-size: 0.95rem;
      color: #444;
      margin-top: 0.3rem;
      display: flex; /* For checkbox alignment */
      align-items: center;
    }
    .bonus-line label {
      display: flex;
      align-items: center;
      width: 100%;
      cursor: pointer;
    }
    .bonus-line input[type="checkbox"] {
      transform: scale(1.1);
      margin-right: 0.4rem;
    }

    /* Standard bonus class - main 1-point bonuses. */
    .bonus {
      font-size: 0.95rem;
      color: #444;
      margin-top: 0.3rem;
      display: flex; /* Use flex to align checkbox and text horizontally */
      align-items: center; /* Vertically align items in the flex container */
      width: 100%; /* Take full width of parent */
    }
    .bonus label { /* Ensure the label acts as the flex container for its content */
        display: flex;
        align-items: center;
        width: 100%;
        cursor: pointer;
    }
    .bonus input[type="checkbox"] {
        transform: scale(1.1);
        margin-right: 0.4rem;
    }

    /* Old rainbow class, REVERTED TO ORIGINAL DISPLAY */
    .rainbow {
      font-size: 0.95rem;
      color: #444;
      margin-top: 0.3rem;
      /* No display:flex here, each label should be a block within rainbow div */
    }
    .rainbow label {
      display: flex; /* Each label itself should be a flex container for its checkbox and text */
      align-items: center;
      width: 100%; /* Take full full width of the rainbow div */
      cursor: pointer;
      margin-bottom: 0.2rem; /* Add a little space between rainbow options */
    }
    .rainbow input[type="checkbox"] {
      transform: scale(1.1);
      margin-right: 0.4rem;
    }


    #reset-btn {
      margin: 2rem auto 1rem;
      display: block;
      font-size: 1.3rem;
      background: #e74c3c;
      color: white;
      border: none;
      padding: 0.7rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
      transition: background 0.3s ease;
    }
    #reset-btn:hover {
      background: #c0392b;
    }

    #secret-challenge-section {
      opacity: 0;
      max-height: 0;
      overflow: hidden;
      transition: opacity 0.7s ease-in-out, max-height 0.7s ease-in-out;
      pointer-events: none;
      margin-top: 2rem;
      border-top: 2px dashed #ccc;
      padding-top: 1rem;
      text-align: center;
    }
    #secret-challenge-section.revealed {
      opacity: 1;
      max-height: 3000px;
      pointer-events: auto;
    }
    #secret-challenge-section h2 {
        color: #5a2a8b;
    }
    .secret-subheader {
        text-align: center;
        color: #4a1c7c;
        margin-top: 1.5rem;
        margin-bottom: 1rem;
        font-size: 1.3rem;
        font-weight: bold;
    }
    /* Style for emojis within subheaders */
    .secret-subheader .subheader-emoji {
        font-size: 1.1em; /* Slightly larger than surrounding text */
        vertical-align: middle; /* Align with text baseline */
        margin: 0 0.2em; /* Spacing around emojis */
    }

    #secret-challenges-count {
      text-align: center;
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
      color: #5a2a8b;
      opacity: 0;
      display: none; /* Initially hidden by default */
      transition: opacity 0.7s ease-in-out;
    }
    /* This class is now applied if SECRET_EVER_UNLOCKED_KEY is true */
    #secret-challenges-count.visible-tracker {
        display: block;
        opacity: 1;
    }

    .secret-desc-new-line {
        display: block;
        margin-top: 0.3em;
        font-style: italic;
        color: #666;
    }

    #hide-secret-btn {
        margin-top: 2rem;
        padding: 0.6rem 1.2rem;
        background-color: #5a2a8b;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1rem;
        transition: background 0.3s ease;
    }
    #hide-secret-btn:hover {
        background-color: #4a1c7c;
    }

    #unlock-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #5a2a8b;
      color: white;
      padding: 25px 50px;
      border-radius: 10px;
      font-size: 2.2em;
      font-weight: bold;
      text-align: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
      letter-spacing: 1px;
    }

    #unlock-notification.show {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.1);
      animation: unlockFadeOut 2s forwards;
    }

    @keyframes unlockFadeOut {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
      80% { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.0); }
    }
  </style>
</head>
<body>

<h1 id="main-heading">Pub Crawl Challenge List</h1>

<div id="riddle-container" class="riddle-hidden">
  A grand adventure, now begins,<br>
  Through taverns vast, where joy within.<br>
  Ten trials await, for laughs and cheer,<br>
  Your progress charted, banishing fear.<br><br>

  But a subtle code, for the keenest mind,<br>
  Unlocks wonders, you'll surely find...<br>
  Find where the sipped is swiftly drained,<br>
  Then a backward journey, boldly gained.<br>
  Follow quickly with a hand adorned,<br>
  Three in a row, a secret born!<br><br>

  What am I, on this journey grand,<br>
  That guides your steps, with secrets at hand?
  <div id="riddle-answer">... Your Challenge List!</div>
  <button id="hide-riddle-btn">Hide Riddle</button>
</div>

<button id="show-riddle-btn" class="visible">Show Riddle</button>

<div id="challenge-container"></div>

<div id="secret-challenge-section">
    <h2 style="text-align: center;">🤫 Secret Challenges! 🤫</h2>
    <div id="secret-challenge-container"></div>
    <button id="hide-secret-btn">Hide Secret Challenges</button>
</div>

<div style="text-align: center; margin-top: 2rem; font-size: 1.2rem;">
  <div id="main-count">✔️ Challenges Completed: 0 / 10</div>
  <div id="bonus-count">⭐ Bonus Points Earned: 0 / 0</div>
  <div id="secret-challenges-count">🎁 Secret Challenges Score: 0 / 0</div>
  <div id="total-score">🏆 Total Score: 0 / 10</div>
</div>

<button id="reset-btn">Reset Progress</button>

<div id="unlock-notification">
  SECRET CHALLENGES UNLOCKED!
</div>

<script>
  const STORAGE_KEY = "pubCrawlChallengeProgress";
  const RIDDLE_HIDDEN_KEY = "isRiddleHidden";
  const SECRET_UNLOCKED_KEY = "areSecretChallengesUnlocked";
  const SECRET_EVER_UNLOCKED_KEY = "haveSecretChallengesEverBeenUnlocked";

  // Challenges array exactly as per your Google Doc
  const challenges = [
    { id: 0, emojis: ["🔄", "👕"], title: "Closet Shuffle.", desc: "Swap an item of clothing with someone for the entire time at one location." },
    { id: 1, emojis: ["🌈", "🍹"], title: "Taste the Rainbow.", desc: "Drink two different colours of the rainbow — use cocktails, shots, or even mixers.", rainbow: true },
    { id: 2, emojis: ["🥤", "🍸"], title: "The Diana Special.", desc: "Finish your entire drink using three (or more) straws at once." },
    { id: 3, emojis: ["🔙", "🚶‍♂️"], title: "Backwards Journey.", desc: "Walk backwards between any two crawl stops. Safety first, though — have a guide!" },
    { id: 4, emojis: ["🧦", "✋"], title: "Sock Puppet Hour.", desc: "Wear a sock on your right hand for the entire time at one location. Introduce it as your new drinking buddy." },
    { id: 5, emojis: ["🕺", "💃"], title: "Dance-Off Destiny.", desc: "Join or start a dance-off.", bonus: "If you win or get strangers to cheer." },
    { id: 6, emojis: ["🤫", "📎"], title: "The Sneaky Peg.", desc: "Clip your peg on someone without them noticing — it must stay there for 15 minutes. Proof required!", bonus: "Someone leaves a crawl stop wearing your peg.", bonusAlwaysEnabled: true },
    { id: 7, emojis: ["🎭", "🗣️"], title: "Accent Order (Encore).", desc: "Order your drink in a full accent (e.g. French, pirate, cowboy, Scottish).", bonus: "Stay in character until you have finished your drink." },
    { id: 8, emojis: ["📸", "🤳"], title: "The Hospitality Selfie.", desc: "Take a selfie with either a bartender or a bouncer.", bonus: "If they smile." },
    { id: 9, emojis: ["🍻", "🥂"], title: "The Icebreaker Toast.", desc: "Walk up to a complete stranger (or another group) and confidently give a short but passionate toast in their honour.", bonus: "They toast back." }
  ];

  // Secret Challenges array exactly as previously defined and confirmed
  const secretChallenges = [
    { type: "subheader", text: "<span class='subheader-emoji'>💧</span> Owen's Hydration Fund <span class='subheader-emoji'>💧</span>" },
    { id: 10, emojis: ["💰", "🍹"], title: "The Generosity Gambit: Round One.", desc: "Buy Owen a drink.", points: 1},
    { id: 11, emojis: ["💸", "🍸"], title: "The Double Down Delight: Round Two.", desc: "Buy Owen *another* drink.", points: 2},
    { id: 12, emojis: ["🤑", "🥂"], title: "The Triple Treat Triumph: Round Three.", desc: "Buy Owen a *third* drink.", points: 3},
    
    { type: "subheader", text: "<span class='subheader-emoji'>👤👤</span> The Stranger's Directive <span class='subheader-emoji'>❓</span>" },
    { id: 21, emojis: ["🗣️", "❓"], title: "The Stranger's Directive.", desc: "Approach someone not part of your crawl, such as a bartender, security guard, another pub patron, or even a potential future husband, and ask them to give *you* a challenge.", points: 1, bonus: "If you successfully complete the challenge they set.", bonusPoints: 2},
    
    // Cat Crawl Challenge with sequential parts as separate entries for individual checkboxes
    { type: "subheader", text: "<span class='subheader-emoji'>🐾🐾</span> The Cat Crawl Callback <span class='subheader-emoji'>🐾</span>" },
    { id: 22, emojis: ["🐱", "📸"], title: "The Cat Crawl Callback: First Cat.", desc: "Get a photo with one cat. This challenge is a callback to a legendary previous pub crawl.", points: 1},
    { id: 23, emojis: ["🐱", "📸"], title: "The Cat Crawl Callback: Second Cat.", desc: "Get a photo with a second unique cat.", points: 1},
    { id: 24, emojis: ["🐱", "📸"], title: "The Cat Crawl Callback: Third Cat.", desc: "Get a photo with a third unique cat.", points: 1},

    { type: "subheader", text: "📢 Public Embarrassment Tour 📢" },
    { id: 13, emojis: ["🏨", "🗣️"], title: "Occidental Grand Entrance.", desc: "Upon entering the Occidental Hotel, enthusiastically declare:", quote: "“Let the crawl begin! May our memories be blurry and our drinks be strong!”", points: 1},
    { id: 14, emojis: ["🥷", "🗣️"], title: "Uncle Ming's Mystic Welcome.", desc: "As you enter Uncle Ming’s, state with gravitas:", quote: "“We come seeking wisdom… and whiskey!” (Optional: perform a ninja bow or hands in prayer).", points: 1},
    { id: 15, emojis: ["🚋", "🗣️"], title: "Light Rail Loudspeaker.", desc: "Boarding the Light Rail from Wynyard, announce:", quote: "“To the next round, we ride! Conduct us to chaos!”", points: 1},
    { id: 16, emojis: ["⚓", "🗣️"], title: "The Ship Inn's Salty Salute.", desc: "Entering The Ship Inn, exclaim:", quote: "“Ahoy, Ship Inn! We’re here to sail the seas of spirits!”", points: 1},
    { id: 17, emojis: ["🍽", "🗣️"], title: "Jackson's Dinner Declaration.", desc: "At Jackson’s on George, proclaim:", quote: "“Refuel the adventurers! Ale in hand, fork at the ready!”", points: 1},
    { id: 18, emojis: ["🏰", "🗣️"], title: "Fortune's Fierce Proclamation.", desc: "Upon entering the Fortune of War, yell:", quote: "“To battle! We drink in the name of victory!” (Optional: mime a sword-in-the-air).", points: 1},
    { id: 19, emojis: ["🍺", "🗣️"], title: "Munich Brauhaus Boisterous Bonjour.", desc: "Inside Munich Brauhaus, bellow:", quote: "“Prost! Bring forth the beer and the bratwurst!” (Ensure to yell 'Prost!' and clink imaginary glasses).", points: 1},
    { id: 20, emojis: ["💃", "🗣️"], title: "Dance Floor Dynamo.", desc: "As you enter Cruise Bar and/or Orient Hotel, declare:", quote: "“We danced our way through drinks — now let’s drink our way through dance!”", points: 1}
  ];

  const sequentialSections = [
    { name: "Owen's Hydration Fund", startId: 10, endId: 12, order: [10, 11, 12] },
    { name: "The Cat Crawl Callback", startId: 22, endId: 24, order: [22, 23, 24] }
  ];

  // This array will contain all challenges for easy iteration, excluding subheaders.
  const allChallenges = challenges.concat(secretChallenges.filter(ch => ch.type !== 'subheader'));

  // Function to get emoji code for a given emoji character
  function getEmojiCode(emoji) {
      const charCode = emoji.codePointAt(0);
      return charCode.toString(16);
  }

  function createChallengeElement(challenge) {
    const challengeItem = document.createElement('div');
    challengeItem.className = 'challenge-item';

    const checkboxContainer = document.createElement('div');
    checkboxContainer.className = 'checkbox-container';

    const mainCheckbox = document.createElement('input');
    mainCheckbox.type = 'checkbox';
    mainCheckbox.id = `chk${challenge.id}`;
    mainCheckbox.dataset.challengeId = challenge.id; // Store ID for easy lookup
    checkboxContainer.appendChild(mainCheckbox);

    const emojisContainer = document.createElement('div');
    emojisContainer.className = 'emojis-container';
    if (challenge.emojis) {
      challenge.emojis.forEach(emojiChar => {
        const emojiSpan = document.createElement('span');
        emojiSpan.className = 'emoji';
        emojiSpan.textContent = emojiChar;
        emojisContainer.appendChild(emojiSpan);
      });
    }
    checkboxContainer.appendChild(emojisContainer); // Append emojis next to checkbox

    challengeItem.appendChild(checkboxContainer);

    const challengeDetails = document.createElement('div');
    challengeDetails.className = 'challenge-details';

    const titleElement = document.createElement('div');
    titleElement.className = 'challenge-title';
    titleElement.textContent = challenge.title;
    challengeDetails.appendChild(titleElement);

    const descElement = document.createElement('div');
    descElement.className = 'challenge-desc';
    descElement.textContent = challenge.desc;
    challengeDetails.appendChild(descElement);

    if (challenge.quote) {
        const quoteElement = document.createElement('div');
        quoteElement.className = 'secret-desc-new-line';
        quoteElement.textContent = `Quote: ${challenge.quote}`;
        challengeDetails.appendChild(quoteElement);
    }

    if (challenge.bonus) {
      if (challenge.id === 6) { // Special styling for Sneaky Peg
          const bonusLine = document.createElement('div');
          bonusLine.className = 'bonus-line';
          const bonusLabel = document.createElement('label');
          const bonusCheckbox = document.createElement('input');
          bonusCheckbox.type = 'checkbox';
          bonusCheckbox.id = `chk${challenge.id}b`;
          bonusCheckbox.dataset.challengeId = challenge.id;
          bonusCheckbox.dataset.bonus = 'true';
          bonusLabel.appendChild(bonusCheckbox);
          const bonusText = document.createElement('span');
          bonusText.textContent = `Bonus: ${challenge.bonus}`;
          bonusLabel.appendChild(bonusText);
          bonusLine.appendChild(bonusLabel);
          challengeDetails.appendChild(bonusLine);
      } else { // Standard bonus
          const bonusDiv = document.createElement('div');
          bonusDiv.className = 'bonus';
          const bonusLabel = document.createElement('label');
          const bonusCheckbox = document.createElement('input');
          bonusCheckbox.type = 'checkbox';
          bonusCheckbox.id = `chk${challenge.id}b`;
          bonusCheckbox.dataset.challengeId = challenge.id;
          bonusCheckbox.dataset.bonus = 'true';
          bonusLabel.appendChild(bonusCheckbox);
          const bonusText = document.createElement('span');
          bonusText.textContent = `Bonus: ${challenge.bonus}`;
          bonusLabel.appendChild(bonusText);
          bonusDiv.appendChild(bonusLabel);
          challengeDetails.appendChild(bonusDiv);
      }
    }

    if (challenge.rainbow) {
      const rainbowDiv = document.createElement('div');
      rainbowDiv.className = 'rainbow';
      // Added explanatory text for the rainbow bonus scoring
      const rainbowHint = document.createElement('div');
      rainbowHint.textContent = "Bonus: +1 point for each additional color after the first two.";
      rainbowHint.style.fontSize = "0.9em";
      rainbowHint.style.color = "#666";
      rainbowHint.style.marginBottom = "0.5rem";
      challengeDetails.appendChild(rainbowHint);

      const colors = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet'];
      colors.forEach((color, index) => {
        const colorId = `${challenge.id}-color-${index}`;
        const colorLabel = document.createElement('label');
        const colorCheckbox = document.createElement('input');
        colorCheckbox.type = 'checkbox';
        colorCheckbox.id = colorId;
        colorCheckbox.dataset.challengeId = challenge.id;
        colorCheckbox.dataset.rainbowColor = color;
        colorLabel.appendChild(colorCheckbox);
        const colorText = document.createElement('span');
        colorText.textContent = color;
        colorLabel.appendChild(colorText);
        rainbowDiv.appendChild(colorLabel);
      });
      challengeDetails.appendChild(rainbowDiv);
    }

    challengeItem.appendChild(challengeDetails);
    return challengeItem;
  }

  function renderChallenges() {
    const challengeContainer = document.getElementById('challenge-container');
    challengeContainer.innerHTML = ''; // Clear existing challenges

    challenges.forEach(challenge => {
      challengeContainer.appendChild(createChallengeElement(challenge));
    });

    const secretChallengeContainer = document.getElementById('secret-challenge-container');
    secretChallengeContainer.innerHTML = ''; // Clear existing secret challenges

    secretChallenges.forEach(challenge => {
      if (challenge.type === "subheader") {
        const subheader = document.createElement('div');
        subheader.className = 'secret-subheader';
        subheader.innerHTML = challenge.text;
        secretChallengeContainer.appendChild(subheader);
      } else {
        secretChallengeContainer.appendChild(createChallengeElement(challenge));
      }
    });

    addEventListeners(); // Re-add event listeners after rendering
    loadProgress(); // Load saved progress
    updateScore(); // Update score display
  }

  function addEventListeners() {
    document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.removeEventListener('change', handleCheckboxChange); // Prevent duplicate listeners
      checkbox.addEventListener('change', handleCheckboxChange);
    });

    // Event listeners for riddle hide/show buttons
    document.getElementById('hide-riddle-btn').addEventListener('click', hideRiddle);
    document.getElementById('show-riddle-btn').addEventListener('click', showRiddle);

    // Event listeners for secret challenges hide button
    const hideSecretBtn = document.getElementById('hide-secret-btn');
    if (hideSecretBtn) {
        hideSecretBtn.removeEventListener('click', hideSecretChallenges);
        hideSecretBtn.addEventListener('click', hideSecretChallenges);
    }

    // Event listener for reset button
    document.getElementById('reset-btn').addEventListener('click', resetProgress);
  }

  function handleCheckboxChange(event) {
    saveProgress();
    updateScore();
    updateSequentialChallengeStates(); // Update sequential challenge states on any change
    checkSecretUnlockCondition(); // Check secret unlock condition
  }

  function saveProgress() {
    const progress = {};
    document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      progress[checkbox.id] = checkbox.checked;
    });
    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
    localStorage.setItem(RIDDLE_HIDDEN_KEY, document.getElementById('riddle-container').classList.contains('riddle-hidden'));
    localStorage.setItem(SECRET_UNLOCKED_KEY, document.getElementById('secret-challenge-section').classList.contains('revealed'));
    localStorage.setItem(SECRET_EVER_UNLOCKED_KEY, true); // Set to true once unlocked
  }

  function loadProgress() {
    const savedProgress = JSON.parse(localStorage.getItem(STORAGE_KEY)) || {};
    document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
      checkbox.checked = savedProgress[checkbox.id] || false;
    });

    // Load riddle state
    const isRiddleHidden = localStorage.getItem(RIDDLE_HIDDEN_KEY) === 'true';
    const riddleContainer = document.getElementById('riddle-container');
    const showRiddleBtn = document.getElementById('show-riddle-btn');
    if (isRiddleHidden) {
      riddleContainer.classList.add('riddle-hidden');
      showRiddleBtn.classList.add('visible');
    } else {
      riddleContainer.classList.remove('riddle-hidden');
      showRiddleBtn.classList.remove('visible');
    }

    // Load secret section state
    const secretSection = document.getElementById('secret-challenge-section');
    const wasSecretUnlocked = localStorage.getItem(SECRET_UNLOCKED_KEY) === 'true';
    if (wasSecretUnlocked) {
        secretSection.classList.add('revealed');
    } else {
        secretSection.classList.remove('revealed');
    }

    // Show/hide secret challenges count permanently if it was ever unlocked
    const secretChallengesCount = document.getElementById('secret-challenges-count');
    const hasSecretEverBeenUnlocked = localStorage.getItem(SECRET_EVER_UNLOCKED_KEY) === 'true';
    if (hasSecretEverBeenUnlocked) {
        secretChallengesCount.classList.add('visible-tracker');
    } else {
        secretChallengesCount.classList.remove('visible-tracker');
    }

    updateSequentialChallengeStates(); // Apply sequential states after loading
    checkSecretUnlockCondition(); // Re-check unlock condition on load
    updateScore(); // Ensure score is up-to-date after loading
  }

  function updateScore() {
    let mainCompleted = 0;
    let bonusEarned = 0;
    let secretScore = 0;
    let maxBonusPoints = 0; // This will now dynamically count based on `bonus` property existence and Rainbow logic
    let maxSecretPoints = 0; // Explicitly set later

    challenges.forEach(ch => {
      const mainCheckbox = document.getElementById(`chk${ch.id}`);
      if (mainCheckbox && mainCheckbox.checked) {
        mainCompleted++;
      }

      // Handle "Taste the Rainbow" (ID 1) main challenge and its unique bonus points
      if (ch.rainbow && ch.id === 1) {
        const colors = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet'];
        let colorsChecked = 0;
        colors.forEach((color, index) => {
          const colorCheckbox = document.getElementById(`${ch.id}-color-${index}`);
          if (colorCheckbox && colorCheckbox.checked) {
            colorsChecked++;
          }
        });

        // Main challenge for Taste the Rainbow: 1 point if 2+ colors
        if (colorsChecked >= 2 && mainCheckbox) {
          mainCheckbox.checked = true;
        } else if (mainCheckbox) {
          mainCheckbox.checked = false;
        }

        // Bonus for Taste the Rainbow: 1 point for each color AFTER the initial 2
        // So, if 3 colors are checked, bonusEarned gets +1. If 4, +2, etc.
        if (colorsChecked > 2) {
          bonusEarned += (colorsChecked - 2);
        }
        // Taste the Rainbow can contribute up to 5 bonus points (colors 3 through 7)
        maxBonusPoints += 5; 
      } else if (ch.bonus) { // Standard bonus for other challenges
        maxBonusPoints++; // Increment maxBonusPoints only if a standard bonus is defined for this challenge.
        const bonusCheckbox = document.getElementById(`chk${ch.id}b`);
        if (bonusCheckbox && bonusCheckbox.checked) {
          bonusEarned++;
        }
      }
    });

    secretChallenges.filter(ch => ch.type !== 'subheader').forEach(ch => {
        const mainCheckbox = document.getElementById(`chk${ch.id}`);
        // Calculate current secret score
        if (mainCheckbox && mainCheckbox.checked) {
            if (ch.points) secretScore += ch.points;
            else secretScore += 1; // Default 1 point if not specified (e.g., Public Embarrassment)
        }
        const bonusCheckbox = document.getElementById(`chk${ch.id}b`);
        if (bonusCheckbox && bonusCheckbox.checked && ch.bonusPoints) {
            secretScore += ch.bonusPoints;
        }

        // maxSecretPoints is set to a fixed value as per user's specific request
    });

    // Explicitly set maxSecretPoints to 20 as per user's specific request for the secret section total
    maxSecretPoints = 20;

    const totalChallenges = challenges.length; // Still 10 main challenges
    document.getElementById('main-count').textContent = `✔️ Challenges Completed: ${mainCompleted} / ${totalChallenges}`;
    document.getElementById('bonus-count').textContent = `⭐ Bonus Points Earned: ${bonusEarned} / ${maxBonusPoints}`;
    document.getElementById('secret-challenges-count').textContent = `🎁 Secret Challenges Score: ${secretScore} / ${maxSecretPoints}`;
    document.getElementById('total-score').textContent = `🏆 Total Score: ${mainCompleted + bonusEarned + secretScore} / ${totalChallenges + maxBonusPoints + maxSecretPoints}`;
  }

  function resetProgress() {
    if (confirm("Are you sure you want to reset all progress? This cannot be undone.")) {
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(RIDDLE_HIDDEN_KEY);
      localStorage.removeItem(SECRET_UNLOCKED_KEY);
      localStorage.removeItem(SECRET_EVER_UNLOCKED_KEY);
      renderChallenges(); // Re-render to clear all checkboxes and states
    }
  }

  function hideRiddle() {
    document.getElementById('riddle-container').classList.add('riddle-hidden');
    document.getElementById('show-riddle-btn').classList.add('visible');
    saveProgress();
  }

  function showRiddle() {
    document.getElementById('riddle-container').classList.remove('riddle-hidden');
    document.getElementById('show-riddle-btn').classList.remove('visible');
    saveProgress();
  }

  // --- Secret Challenges Logic ---

  function checkSecretUnlockCondition() {
    const mainCompleted = challenges.filter(ch => document.getElementById(`chk${ch.id}`).checked).length;
    const secretSection = document.getElementById('secret-challenge-section');
    const secretChallengesCount = document.getElementById('secret-challenges-count');

    // Condition: 3 completed main challenges, 1 bonus, 1 specific trigger emoji click (not yet implemented as emoji is part of riddle)
    // For now, based on previous discussion, the trigger is 3 main challenges + 1 bonus.
    const isUnlockedByMain = mainCompleted >= 3 && document.querySelectorAll('input[data-bonus="true"]:checked').length >= 1;

    // Additional trigger: Check for the specific sequence for the riddle's unlock.
    // Riddle sequence: Drink finished (ID 2), Backward walk (ID 3), Sock Puppet (ID 4)
    const drinkFinished = document.getElementById('chk2')?.checked;
    const backwardWalk = document.getElementById('chk3')?.checked;
    const sockPuppet = document.getElementById('chk4')?.checked;
    const isUnlockedByRiddleSequence = drinkFinished && backwardWalk && sockPuppet;


    if (isUnlockedByMain || isUnlockedByRiddleSequence) { // Combined unlock condition
        if (!secretSection.classList.contains('revealed')) {
            secretSection.classList.add('revealed');
            secretChallengesCount.classList.add('visible-tracker');
            localStorage.setItem(SECRET_EVER_UNLOCKED_KEY, true); // Mark as ever unlocked
            showUnlockNotification();
        }
    } else {
        // If the condition is no longer met, hide the section again (unless it was ever unlocked, then just disable checkboxes)
        if (!localStorage.getItem(SECRET_EVER_UNLOCKED_KEY)) {
             secretSection.classList.remove('revealed');
             // Also hide the counter if it's not ever been unlocked
             secretChallengesCount.classList.remove('visible-tracker');
        }
    }
    saveProgress(); // Ensure unlock state is saved
    updateSequentialChallengeStates(); // Update visibility based on new unlock state
    toggleSecretChallengeCheckboxes(); // Manage checkbox state (disabled/enabled)
  }

  function showUnlockNotification() {
      const notification = document.getElementById('unlock-notification');
      notification.classList.add('show');
      setTimeout(() => {
          notification.classList.remove('show');
      }, 2000); // Notification visible for 2 seconds
  }

  function hideSecretChallenges() {
      const secretSection = document.getElementById('secret-challenge-section');
      secretSection.classList.remove('revealed');
      saveProgress();
      // Do not hide the secret challenges count if it was ever unlocked
  }

  function updateSequentialChallengeStates() {
    // Disable all sequential secret challenge checkboxes by default (unless they are the first in their sequence or unlocked)
    secretChallenges.filter(ch => ch.type !== 'subheader').forEach(ch => {
        const checkbox = document.getElementById(`chk${ch.id}`);
        const bonusCheckbox = document.getElementById(`chk${ch.id}b`);
        if (checkbox) {
            checkbox.disabled = true; // Disable all by default
            if (bonusCheckbox) bonusCheckbox.disabled = true; // Disable bonus too
        }
    });

    const secretSectionRevealed = document.getElementById('secret-challenge-section').classList.contains('revealed');

    if (!secretSectionRevealed) {
        // If the entire secret section isn't revealed, all secret checkboxes remain disabled.
        return;
    }

    // Enable Public Embarrassment challenges if the secret section is revealed
    secretChallenges.filter(ch => ch.type !== 'subheader' && ch.title.includes("Public Embarrassment Tour")).forEach(ch => {
        const checkbox = document.getElementById(`chk${ch.id}`);
        if (checkbox) checkbox.disabled = false;
    });


    sequentialSections.forEach(section => {
      for (let i = 0; i < section.order.length; i++) {
        const currentChallengeId = section.order[i];
        const currentCheckbox = document.getElementById(`chk${currentChallengeId}`);
        const currentBonusCheckbox = document.getElementById(`chk${currentChallengeId}b`);

        if (i === 0) {
          // First challenge in sequence is always enabled if the secret section is revealed
          if (currentCheckbox) currentCheckbox.disabled = false;
          if (currentBonusCheckbox) currentBonusCheckbox.disabled = false;
        } else {
          // Subsequent challenges depend on the previous one being checked
          const prevChallengeId = section.order[i - 1];
          const prevCheckbox = document.getElementById(`chk${prevChallengeId}`);

          if (prevCheckbox && prevCheckbox.checked) {
            if (currentCheckbox) currentCheckbox.disabled = false;
            if (currentBonusCheckbox) currentBonusCheckbox.disabled = false;
          } else {
            // If previous is not checked, disable current and all subsequent in this sequence
            if (currentCheckbox) currentCheckbox.disabled = true;
            if (currentBonusCheckbox) currentBonusCheckbox.disabled = true;
            // Also uncheck them if they become disabled
            if (currentCheckbox) currentCheckbox.checked = false;
            if (currentBonusCheckbox) bonusCheckbox.checked = false;
          }
        }
      }
    });
    saveProgress(); // Save state after updating disabled flags
    updateScore(); // Update score after potentially unchecking items
  }


  function toggleSecretChallengeCheckboxes() {
      const secretSectionRevealed = document.getElementById('secret-challenge-section').classList.contains('revealed');
      secretChallenges.filter(ch => ch.type !== 'subheader').forEach(ch => {
          const mainCheckbox = document.getElementById(`chk${ch.id}`);
          const bonusCheckbox = document.getElementById(`chk${ch.id}b`);

          // Only enable if the secret section is revealed AND it's not part of a sequential chain that's currently disabled
          // The updateSequentialChallengeStates() function handles the disabling/enabling based on sequence
          // So, if the section is revealed, and updateSequentialChallengeStates() *doesn't* disable it, it should be enabled.
          if (mainCheckbox) {
              if (secretSectionRevealed) {
                  // If it's a Public Embarrassment challenge, always enable it when secret section is revealed
                  if (ch.title.includes("Public Embarrassment Tour") || ch.id === 21) { // Also enable Stranger's Directive
                      mainCheckbox.disabled = false;
                      if (bonusCheckbox) bonusCheckbox.disabled = false;
                  } else {
                      // For other secret challenges, updateSequentialChallengeStates() would have already set their disabled state
                      // We just need to make sure we don't accidentally enable them here if they're part of a sequential chain that's not ready.
                      // The sequential logic already sets disabled=true for non-first elements if prev is not checked.
                      // So, if mainCheckbox.disabled is still true here, it means sequential logic kept it disabled.
                  }
              } else {
                  // If the secret section is NOT revealed, disable all secret checkboxes.
                  mainCheckbox.disabled = true;
                  if (bonusCheckbox) bonusCheckbox.disabled = true;
              }
          }
      });
      saveProgress(); // Ensure state is saved
      updateScore(); // Update score after state changes
  }


  // Initial render when the DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    renderChallenges();
    loadProgress(); // Ensure progress is loaded after rendering
    // Initial check for secret unlock status and apply visibility
    checkSecretUnlockCondition();
  });
</script>

</body>
</html>
